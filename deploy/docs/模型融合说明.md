# 模型融合

## 背景
需要根据客户对于场景要求的精度和速度的不同，需要才要fp32或者int8模型，使用取决于上层应用，因为在模型转换时就需要转换多做精度模型，并且打包模型，在运行时决定使用哪一个；

## 模型打包结构体

C++解析函数代码：
```c++
// 模型信息结构体
typedef struct {
    char model_name[64];  // 模型名称
    int model_type;  // 模型类型，0：fp32，1：fp16, 2：int16， 3：int8
    unsigned char md5[16];  // md5值
    int model_size;  // 模型大小
    unsigned long data_addr_start; // 数据值开始地址
    unsigned long data_addr_end; // 权重值开始地址
} ModelInfo_t

// 模型打包文件头
typedef struct {
    int magic;  //magic数，用于标识此文件为模型打包文件
    int version;  //版本号，用于标识此文件的版本
    int model_num;  // 模型个数
    ModelInfo_t *model_info;  // 模型信息
}MultiModel_t;

// 多个模型打包函数
int pack_model(std::vector<std::string> model_paths)
{
    model_infos.magic = 0x12345678;
    model_infos.version = 1;
    model_infos.model_num = model_paths.size();
    model_infos.model_info = (ModelInfo_t *)malloc(sizeof(ModelInfo_t) * model_paths.size());
    int data_begin_addr = sizeof(MultiModel_t) + sizeof(ModelInfo_t) * model_paths.size();

    for (int i = 0; i < model_paths.size(); i++){
        auto & model_path = model_paths[i];
        // 读取模型文件
        FILE *fp = fopen(model_path.c_str(), "rb");
        if (fp == NULL) {
            printf("open file %s failed\n", model_path.c_str());
            return NULL;
        }

        // 读取模型文件大小
        fseek(fp, 0, SEEK_END);
        int model_size = ftell(fp);
        fseek(fp, 0, SEEK_SET);

        // 读取模型文件内容
        char *model_data = (char *)malloc(model_size);
        fread(model_data, model_size, 1, fp);

        // 计算模型文件md5值
        unsigned char md5[16];
        MD5_CTX md5_ctx;
        MD5_Init(&md5_ctx);
        MD5_Update(&md5_ctx, model_data, model_size);
        MD5_Final(md5, &md5_ctx);

        // 关闭文件
        fclose(fp);

        // 模型信息结构体
        ModelInfo_t *model_info = model_infos.model_info + i;
        strcpy(model_info->model_name, model_path.c_str());
        model_info->model_type = 0;
        memcpy(model_info->md5, md5, 16);
        model_info->model_size = model_size;
        model_info->data_addr_start = data_begin_addr + model_size * i;
        model_info->data_addr_end = data_begin_addr + model_size * (i + 1);
    }
}

// 解析函数
// 参数是模型打包文件的路径
// 返回值是模型信息结构体
int parse_model_info(char *model_path, MultiModel_t model_infos )
{
    // 读取模型打包文件
    FILE *fp = fopen(model_path, "rb");
    if (fp == NULL) {
        printf("open file %s failed\n", model_path);
        return NULL;
    }

    // 读取模型打包文件头
    MultiModel_t model_infos;
    fread(&model_infos, sizeof(MultiModel_t), 1, fp);

    // 读取模型信息
    ModelInfo_t *model_info = (ModelInfo_t *)malloc(sizeof(ModelInfo_t) * model.model_num);
    fread(model_info, sizeof(ModelInfo_t), model.model_num, fp);

    model_infos.model_info = model_info;

    // 关闭文件
    fclose(fp);

    return 0;
}

// 使用示例

```
